export default {
  "content": "> ES11 也就是ECMAScript2020版本, 是相对于2020 的ES新版本的特性更新,本文介绍ES11的概念和使用方法.\n\n### 总览\n* class类的私有变量 #\n* Promise.allSettled\n* String.prototype.matchAll\n* BigInt\n* 空值合并运算符??\n* 可选链式云算法?.\n* 按需获取动态import\n* globalThis\n\n__注意: 当前所有新特性都在chrome 83.0版本进行测试__\n\n#### 1. class类的私有变量 #\n在ES11 之前js是没有class类的私有变量的概念, 我们程序员一般使用 '_' 开始符号代表了私有变量,列如 ___name__ 代表了class类中name属性为私有的,而Typescript使用private 前缀代表私有属性或者方法. ES11 中使用# 代表类中的属性为私有变量.\n_code\n```\nclass Dog {\n  #name = 'owen'\n  age = 18\n  getInfo(){\n    console.log(`dog name is ${this.#name} age is ${this.age}`)\n  }\n}\n\nconst dogInstance = new Dog() // dog name is owen age is 18\n\ndogInstance.getInfo()\nconsole.log(dogInstance.#name) // Uncaught SyntaxError: Private field '#name' must be declared in an enclosing class\n```\n#### 2. Promise.allSettled\nES6引入Promise以来, Promise支持的组合型传入类型的方法只有: promise.all 和promise.race , 而这两种方法都会因为 当promise被reject或者报错的时候发生短路,导致之后的promise不会执行. 引入了Promise.allSettled之后,无论promise数组中任何一个promise状态是reslove还是reject,都会执行完毕,最后返回一个状态数组.\n_code\n```\nconst promise1 = new Promise((reslove,reject)=>{\n  setTimeout(()=>{\n    reslove('promise success')\n  },1000)\n})\nconst promise2 = new Promise((reslove,reject)=>{\n  setTimeout(()=>{\n    reject('promise fail')\n  },1000)\n})\n\nconst proResult = Promise.allSettled([promise1,promise2]).then(data=> {\n  console.log(data)\n})\n/*\n[\n  { status: 'fulfilled', value: 'promise success' },\n  { status: 'rejected', reason: 'promise fail' }\n]\n*/\n\n```\n#### 3. String.prototype.matchAll\n__语法: str.machAll(reg)__\n给定一个字符串和一个正则表达式,machAll可以返回所有的与该字符串匹配正则结果的迭代器.下面是mach() 和 machAll() 的对比\n__* 注意:   Reg正则必须是设置了全局模式g的形式，否则会抛出异常TypeError。__\n_code\n```\nconst reg = /name(\\d?)/g\nconst nameGroup = 'name1name2,name3'\nconsole.log(nameGroup.match(reg))\n // [ 'name1', 'name2', 'name3' ]\nconsole.log(nameGroup.matchAll(reg))\n// Object [RegExp String Iterator] {}\nconsole.log(...nameGroup.matchAll(reg))\n/*\n[\n  'name1',\n  '1',\n  index: 0,\n  input: 'name1name2,name3',\n  groups: undefined\n] [\n  'name2',\n  '2',\n  index: 5,\n  input: 'name1name2,name3',\n  groups: undefined\n] [\n  'name3',\n  '3',\n  index: 11,\n  input: 'name1name2,name3',\n  groups: undefined\n]\n*/\n```\n\n#### 4. BigInt 任意精度的整数\nJavaScript对数字大小有严格的固定限制范围, 当大于2的53次方的时候精度就会消失,举个简单的例子:\n```\nconsole.log(2**53) // 9007199254740992\nconsole.log(2**53 === 2**53 + 1) // true\n```\nBiglnt是一种新的数据类型,所以现在js有八种数据类型了 分别是:\n* number\n* string\n* bool\n* null\n* undefined\n* symbol\n* object\n* bigInt\n\nBigInt 产生原因是为了解决js中超过2**53 - 1 的整数精度失效问题. 要创建BigInt只需要在数字的末尾加上一个 'n' 即可. 如下示例:\n_code\n```\nconst bigNumber = 900719925474099211n\nconsole.log(bigNumber + 1n) // 900719925474099212n\n\nconsole.log(bigNumber + 1)\n // TypeError: Cannot mix BigInt and other types, use explicit conversions\n```\n__* 注意BigInt 类型无法跟Number类型互相运算.__\n\n#### 5. 空值合并运算符??\n对TypeScript了解的人,大概很早就开始使用??号符号. 在ES11 新特性之后,?? 号符号可以在我们直接书写js时候使用. \n当我们要判断某个对象的属性不存在那么就取另外一个对象的时候,列如以下情况:\n```\nconst obj = {\n  a: 1,\n  b: 0\n}\nconsole.log(obj.a || 3) // 1\nconsole.log(obj.b || 3) // 3\n```\n如果我们只是想判断obj对象中有那个属性然后取值属性值,没有的话就取值为3 ,这里就会需要多余的判断.\n为了避免这种运算,我们使用?? 运算符\n```\nconsole.log(obj.a ?? 3) // 1\nconsole.log(obj.b ?? 3) // 0\n```\n解析: 空值运算符检查所有值的属性是否为undefined或null。如果不是null或undefined，它将返回初始值，否则将返回??后面的值。\n\n#### 6. 可选链式算法符?.\n同样TypeScript 也已经有了这个运算符,当我们有如下一个对象:\n```\nconst user = {\n  info:{\n    age: 11\n  }\n}\n```\n要取值:\n```\nconsole.log(user.info.age) // 11\n```\n当无法判断user对象中是否有info的属性,info属性下面是否有age属性我们会:\n```\nconsole.log(user&&user.info&&user.info.age)\n```\n而有了?. 运算符之后 可以如此\n```\nconsole.log(user?.info?.age)\n```\n如果一个对象的属性不存在,那么就会直接返回undefined,而不用像之前的一样进行多次的判断.\n\n#### 7. 按需获取动态import\n众所周知,ES Module是一种静态加载模块,静态体现在如下信息:\n* 静态模块: import/export声明只能出现在顶层作用域，不支持按需加载、懒加载\n* 静态标识: 模块标识只能是字符串字面量，不支持运行时动态计算而来的模块名\n\n严格的静态加载,有益于基于源码的静态分析,编译优化,但也同时存在以下的问题:\n* 首屏需要加载所有import引入的模块,不利于首屏优化\n* 模块较多的时候难以确定每个模块加载的含义\n* 仅在特殊情况下需要加载的模块,首次就直接加载影响性能优化.\n\n针对于此, ES11 添加新特性 获取动态import:\n```\nimport(specifier)\n```\nimport函数传入参数模块标识specifier ,返回promise,列如以下示例:\n```\n// lib.js\nfunction add(a, b) {\nreturn a + b\n}\nexports.add = add\nexports.test = 1\n// main.js\nconst loadAdd = () => {\n  import('./lib.js').then(res=>{\n    console.log(res.default.add) // [Function: add]\n    console.log(res.default.test) // 1\n  })\n}\nloadAdd()\n```\n\n#### 8. globalThis\n> ES11 在语言标准的层面，引入`globalThis`作为顶层对象。也就是说，任何环境下，`globalThis`都是存在的，都可以从它拿到顶层对象，指向全局环境下的`this`。\n\n__列如:__\n* 在浏览器中它是 window\n* 在 worker 中它是 self\n* 在 Node.js 中它是global\n......\n所以在ES11之后在任何情况下使用globalThis 都能拿到其顶层对象\n\n### 参考文档\n* [ECMAScript 2020或ES11](https://medium.com/codingtown/ecmascript-2020-aka-es-11-9c547f69d96f)\n* [ES2020（ES11）中的JavaScript新功能](https://medium.com/javascript-in-plain-english/new-javascript-features-in-es2020-c2d76acf9c5a)\n\n### 文章书写不易,转载或引用请注明\n\n\n\n"
}